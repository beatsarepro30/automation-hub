#######################
# Custom Bashrc Logic #
#######################
# If not running interactively, don't do anything
[[ -n $PS1 ]] || return

# Set environment
export HISTCONTROL='ignoredups'
export HISTSIZE=5000
export HISTFILESIZE=5000

export FZF_DEFAULT_OPTS="--height 40% --layout=reverse --border --nth=1.. --query="
export FZF_DEFAULT_COMMAND="fd --type f --hidden --follow --exclude .terraform"
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"

export PATH="$PATH:$HOME/.local/bin"

shopt -s checkwinsize # auto-update terminal size
shopt -s extglob      # enable extended glob patterns

# Overwrite default builtin commands
cd() {
    if (( $# == 0 )); then
        # No arguments: go to home like normal
        builtin cd ~ || return
    elif [[ -d $1 ]]; then
        # If it's a directory, cd as usual
        builtin cd "$1" || return
    elif [[ -f $1 ]]; then
        # If it's a file, cd into its directory
        builtin cd "$(dirname "$1")" || return
    else
        echo "cd: No such file or directory: $1" >&2
        return 1
    fi
}

# Generic Aliases
# https://vikaskyadav.github.io/awesome-bash-alias/
# Clear
alias c="clear"
alias cl="clear"
alias ckear="clear"
alias clr="clear"
# Change Directory
alias .="cd .."
alias ..="cd ../.."
alias ...="cd ../../.."
alias ....="cd ../../../.."
alias .....="cd ../../../../.."
# Docker
dock-run() { sudo docker run -i -t --privileged $@ ;}
dock-exec() { sudo docker exec -i -t $@ /bin/bash ;}
dock-log() { sudo docker logs --tail=all -f $@ ;}
dock-port() { sudo docker port $@ ;}
dock-vol() { sudo docker inspect --format '{{ .Volumes }}' $@ ;}
dock-ip() { sudo docker inspect --format '{{ .NetworkSettings.IPAddress }}' $@ ;}
dock-rmc() { sudo docker rm sudo docker ps -qa --filter 'status=exited' ;}
dock-rmi() { sudo docker rmi -f sudo docker images | grep '^<none>' | awk '{print $3}' ;}
dock-stop() { sudo docker stop $(docker ps -a -q); }
dock-rm() { sudo docker rm $(docker ps -a -q); }
# Git commands
alias gs="git status"
alias gst="git status -sb"
alias gl="git log"
alias gaa="git add -A"
alias gca="git commit -a"
alias gcot="git checkout"
alias gchekout="git checkout"
alias gchckout="git checkout"
alias gckout="git checkout"
alias gsh='git stash'
alias gw='git whatchanged'
alias gitlg="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
alias nah="git clean -df && git checkout -- ."
# History commands
alias h="history"
alias h1="history 10"
alias h2="history 20"
alias h3="history 30"
alias hgrep='history | grep'
# List commands
alias l='ls -lAh'
alias ls='ls -a'
alias la='ls -a'
alias ll='ls -al'
# Confirmation
alias mv='mv -i'
alias cp='cp -i'
alias ln='ln -i'
alias rm='rm -I --preserve-root'

##################
# Enable colours #
##################
alias grep='grep --color=always'
# Enable color support of ls
if ls --color=auto &>/dev/null; then
	alias ls='ls -p --color=auto'
else
	alias ls='ls -p -G'
fi

# Standard 8-color ANSI codes (for use outside PS1, without \[ \])
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[0;37m'
RESET='\033[0m'

# Set of Emojis
CHECKMARK="âœ…"
CROSSMARK="âŒ"
ROCKET="ðŸš€"
PLAN="ðŸ§©"
APPLY="ðŸ› "
DESTROY="ðŸ’£"

# Print a colorized diff
colordiff() {
    local red green cyan reset
    red=$(tput setaf 1 2>/dev/null) || red=''
    green=$(tput setaf 2 2>/dev/null) || green=''
    cyan=$(tput setaf 6 2>/dev/null) || cyan=''
    reset=$(tput sgr0 2>/dev/null) || reset=''

    # Use diff -u for unified diff
    diff -u "$@" | awk -v red="$red" -v green="$green" -v cyan="$cyan" -v reset="$reset" '
    /^-/ { printf("%s%s\n", red, $0); next }
    /^\+/ { printf("%s%s\n", green, $0); next }
    /^@/ { printf("%s%s\n", cyan, $0); next }
    { print $0 reset }
    '

    return "${PIPESTATUS[0]}"
}
alias diff='colordiff'

##################
# Custom Aliases #
##################
alias .bashrc="code ~/.bashrc"
bashrc() {
    local fullpath
    fullpath="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"
    # Replace $HOME with ~
    fullpath="${fullpath/#$HOME/~}"
    code "$fullpath"
}
# Git Aliases and Functions
gcm() {
    # Get current branch
    local branch_part
    branch_part=$(git rev-parse --abbrev-ref HEAD | awk -F/ '{print $NF}')

    # Combine branch part with your commit message
    git commit -am "$branch_part - $*"
}
alias gc="gcm"
gmb() { # git main branch
	local main
	main=$(git symbolic-ref --short refs/remotes/origin/HEAD)
	main=${main#origin/}
	[[ -n $main ]] || return 1
	echo "$main"
}
# Function to get current git branch
git_branch() {
    local branch
    branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [[ -n $branch ]]; then
        echo " ðŸŒ¿\[\033[0;32m\]($branch)\[\033[0m\]"
    fi
}
# Open current git repo (or specific file) in GitHub in default browser
gho() {
    local file=$1
    local remote=${2:-origin}

    # Get git info
    local gr branch url
    gr=$(git rev-parse --show-toplevel) || return 1
    branch=$(git rev-parse --abbrev-ref HEAD) || return 1
    url=$(git config --get "remote.$remote.url") || return 1

    # Determine path relative to git root
    local path=""
    if [[ -n $file ]]; then
        path=$(git ls-files --full-name "$file" 2>/dev/null)
        if [[ -z $path ]]; then
            echo "File '$file' not tracked in git" >&2
            return 1
        fi
        path="/$path"
    fi

    # Extract GitHub username and repo name
    local user repo a
    IFS='/:@' read -ra a <<< "$url"
    user=${a[-2]}
    repo=${a[-1]%.git}

    # Construct GitHub URL
    local gh_url="https://github.com/$user/$repo/tree/$branch$path"
    echo "$gh_url"

    # Open in default browser (cross-platform)
    if command -v xdg-open &>/dev/null; then
        xdg-open "$gh_url" &>/dev/null
    elif command -v powershell.exe &> /dev/null; then
        powershell.exe start "$gh_url";
    elif command -v open &>/dev/null; then
        open "$gh_url"
    elif command -v start &>/dev/null; then
        start "" "$gh_url"
    else
        echo "Could not detect a command to open a browser" >&2
        return 1
    fi
}
gro() {
    git fetch
    git reset --hard "origin/$(git branch --show-current)"
}
grm() {
    git fetch
    git reset --hard "origin/$(gmb)"
}
alias grd="git fetch && git reset --hard origin/develop"
alias gp="git push"
alias gpf="git push -f"
alias gf="git fetch"
alias gch="git fetch --all && git checkout"
alias ga="git add -A"
alias gd="git diff"
cob() {
    if [ -z "$1" ]; then
        echo "Usage: cob <branch-name>"
        return 1
    fi
    git checkout -b "$1" && git push -u origin "$1"
}

# Windows aliases
ex() {
    local path="${1:-.}"
    explorer.exe "$path"
}
# Utils
alias clear_tokens='unset GITHUB_TOKEN'
extract() {
    case "$1" in
        *.tar.bz2) tar xjf "$1" ;;
        *.tar.gz)  tar xzf "$1" ;;
        *.bz2)     bunzip2 "$1" ;;
        *.rar)     unrar x "$1" ;;
        *.gz)      gunzip "$1" ;;
        *.tar)     tar xf "$1" ;;
        *.tbz2)    tar xjf "$1" ;;
        *.tgz)     tar xzf "$1" ;;
        *.zip)     unzip "$1" ;;
        *.7z)      7z x "$1" ;;
        *) echo "donâ€™t know how to extract '$1'" ;;
    esac
}


#####################
# Custom PS1 Prompt #
#####################
set_prompt() {
    local ret=$?
    local exit_str=""
    if (( ret != 0 )); then
        exit_str="\[\033[0;31m\](${ret})"
    fi
    PS1="\[\033[0;36m\]\w$(git_branch)${exit_str}\[\033[0;35m\]\\$ \[\033[0m\]"
}

PROMPT_COMMAND=set_prompt
PROMPT_DIRTRIM=6

####################################
# Custom PATH Management Functions #
####################################

# Show PATH with $HOME replaced by ~
path_show() {
    local -a p
    local dir newpath=""
    IFS=: read -ra p <<< "$PATH"
    for dir in "${p[@]}"; do
        # Replace $HOME at the start with ~
        if [[ $dir == "$HOME"* ]]; then
            dir="~${dir#"$HOME"}"
        fi
        newpath+="$dir:"
    done
    # Remove trailing colon
    newpath=${newpath%:}
    echo "$newpath"
}
alias show_path="path_show"

# Clean PATH: remove duplicates and non-existent directories
path_clean() {
    local dir newpath=""
    local seen=()

    # Split PATH into array by ':'
    IFS=: read -ra dirs <<< "$PATH"

    for dir in "${dirs[@]}"; do
        # Skip empty entries
        [[ -z $dir ]] && continue

        # Skip if directory doesn't exist
        [[ ! -d $dir ]] && continue

        # Skip if already seen
        [[ " ${seen[*]} " == *" $dir "* ]] && continue

        # Add to new path and mark as seen
        newpath+="$dir:"
        seen+=("$dir")
    done

    # Remove trailing colon
    PATH=${newpath%:}
}

####################
# Custom Functions #
####################
# WSL alert function: play Windows sound after any command
wsl_alert() {
    if ! grep -qEi "(Microsoft|WSL)" /proc/version &>/dev/null; then
        # Not WSL, just run the command without alert
        "$@"
        return
    fi

    if [ "$MUTE" = "true" ]; then
        "$@"
        return
    fi

    local ALERT_SOUND='C:\Windows\Media\Alarm04.wav'

    # Run the command passed as arguments
    "$@"

    # Play the Windows sound using PowerShell, even if command fails
    powershell.exe -c "(New-Object Media.SoundPlayer '$ALERT_SOUND').PlaySync()" 
}


#######################
# Final configuration #
#######################
path_clean
# Set up fzf key bindings and fuzzy completion
if command -v fzf >/dev/null 2>&1; then
    eval "$(fzf --bash)"
fi